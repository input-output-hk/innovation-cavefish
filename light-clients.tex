\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
\usepackage{amssymb}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{caption}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%\urlstyle{rm}

%formatting
\newcommand{\var}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\fun}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\type}[1]{\ensuremath{\mathsf{#1}}}
\renewcommand\H{\mathbb{H}}
\newcommand{\Interval}[1]{\type{Interval}[#1]}
\newcommand{\nextdef}{\ensuremath{\\[1em]}}
\newcommand{\where}{\ensuremath{~ ~ \mathbf{where}~ ~ }}

% Macros for eutxo things.
\newcommand{\tx}{\fun{tx}}
\newcommand{\TxId}{\type{TxId}}
\newcommand{\TxIn}{\type{TxIn}}
\newcommand{\Header}{\type{Header}}
\newcommand{\Block}{\type{Block}}
\newcommand{\LState}{\type{LState}}
\newcommand{\Tx}{\type{Tx}}
\newcommand{\Slot}{\type{Slot}}
\newcommand{\B}{\mathbb{B}}
\newcommand{\TxOut}{\type{TxOut}}
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\txId}{\msf{txId}}
\newcommand{\txrefid}{\fun{id}}
\newcommand{\Address}{\ensuremath{\s{Address}}}
\newcommand{\DataHash}{\ensuremath{\s{DataHash}}}
\newcommand{\hashData}{\fun{dataHash}}
\newcommand{\idx}{\fun{index}}
\newcommand{\inputs}{\fun{inputs}}
\newcommand{\outputs}{\fun{outputs}}
\newcommand{\Out}{\type{Output}}
\newcommand{\validityInterval}{\fun{validityInterval}}
\newcommand{\scripts}{\fun{scripts}}
\newcommand{\mint}{\fun{mint}}
\newcommand{\mintScripts}{\fun{mintScripts}}
\newcommand{\mintScsRdmrs}{\fun{mintRdmrs}}
\newcommand{\mintRdmrs}{\fun{mintRdmrs}}
\newcommand{\sigs}{\fun{sigs}}
\newcommand{\fee}{\fun{fee}}
\newcommand{\addr}{\fun{addr}}
\newcommand{\pubkey}{\fun{PubKey}}
\newcommand{\val}{\fun{value}}  %% \value is already defined
\newcommand{\Value}{\type{Value}}
\newcommand{\Redeemer}{\type{Redeemer}}
\newcommand{\TxOutRef}{\type{TxIn}}
\newcommand{\ScriptContext}{\type{ScriptContext}}
\newcommand{\ScriptPurpose}{\type{ScriptPurpose}}
\newcommand{\Datum}{\type{Datum}}
\newcommand{\DCert}{\type{DCert}}
\newcommand{\LCTx}{\type{LCTx}}
\newcommand{\TxInInfo}{\type{TxInInfo}}


\newcommand{\validator}{\fun{validator}}
\newcommand{\redeemer}{\fun{redeemer}}
\newcommand{\datum}{\fun{datum}}
\newcommand{\datumHash}{\fun{datumHash}}
\newcommand{\datumWits}{\fun{datumWitnesses}}
\newcommand{\Data}{\ensuremath{\s{Data}}}
\newcommand{\Input}{\ensuremath{\s{Input}}}
\newcommand{\Output}{\type{Output}}
\newcommand{\OutputRef}{\fun{OutputRef}}
\newcommand{\Signature}{\type{Signature}}
\newcommand{\Ledger}{\ensuremath{\s{Ledger}}}

\newcommand{\outputref}{\fun{outputRef}}
\newcommand{\outputrefs}{\fun{outputRefs}}
\newcommand{\txin}{\fun{in}}
\newcommand{\id}{\fun{id}}
\newcommand{\lookupTx}{\msf{lookupTx}}
\newcommand{\getSpent}{\msf{getSpentOutput}}

% \newcommand{\Tick}{\ensuremath{\s{Tick}}}
\newcommand{\Tick}{\type{Slot}}
\newcommand{\Script}{\type{Script}}
\newcommand{\spent}{\msf{spentOutputs}}
\newcommand{\unspent}{\msf{unspentOutputs}}
\newcommand{\txunspent}{\msf{unspentTxOutputs}}
\newcommand{\eutxotx}{\msf{Tx}}

\newcommand{\consumes}[1]{\msf{consumes(#1)}}
\newcommand{\consumesOne}[1]{\msf{consumesOne(#1)}}
\newcommand{\cid}{\fun{cid}}
\newcommand{\inputValue}{\fun{inputValue}}
\newcommand{\rMin}{r_{\fun{min}}}
\newcommand{\rMax}{r_{\fun{max}}}

\newcommand{\utxotx}{\msf{Tx}}

\newcommand{\N}{\mathbb{N}}

\newcommand{\Quantity}{\type{Quantity}}
\newcommand{\TokenName}{\type{TokenName}}
\newcommand{\Asset}{\ensuremath{\s{Asset}}}
\newcommand{\AssetID}{\type{AssetID}}
\newcommand{\Policy}{\type{Policy}}
\newcommand{\Quantities}{\ensuremath{\s{Quantities}}}
\newcommand{\nativeCur}{\ensuremath{\mathrm{nativeC}}}
\newcommand{\nativeTok}{\ensuremath{\mathrm{nativeT}}}
\newcommand{\valC}{\mkValidator{\mathcal{C}}}
\newcommand{\polC}{\mkPolicy{\mathcal{C}}}
\newcommand\mkValidator[1]{\msf{validator}_#1}
\newcommand\mkPolicy[1]{\msf{policy}_#1}

\newcommand{\PublicKey}{\ensuremath{\s{PubKey}}}
\newcommand{\PubKey}{\ensuremath{\s{PubKey}}}
\newcommand{\PrivateKey}{\ensuremath{\s{PrivateKey}}}

\newcommand{\mkContext}{\ensuremath{\s{mkContext}}}
\newcommand{\mkTxInfo}{\ensuremath{\s{mkTxInfo}}}
\newcommand{\mkVlContext}{\ensuremath{\s{mkValidatorContext}}}
\newcommand{\mkMpsContext}{\ensuremath{\s{mkPolicyContext}}}
\newcommand{\checkSig}{\type{checkSig}}

\newcommand{\applyScript}[1]{\ensuremath{\llbracket#1\rrbracket}}
\newcommand{\applyMPScript}[1]{\ensuremath{\llbracket#1\rrbracket}}

\newcommand{\true}{\type{True}}
\newcommand{\false}{\type{False}}
\newcommand{\True}{\type{True}}
\newcommand{\False}{\type{False}}

\newcommand{\leteq}{:=}

\begin{document}
%
\title{Light Clients for Building UTxO Ledger Transactions}
%
%\titlerunning{Abbreviated paper title} 
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Pyrros Chaidos\inst{1}\orcidID{0000-1111-2222-3333} \and
Aggelos Kiayias\inst{1}\orcidID{1111-2222-3333-4444} \and
Marc Roeschlin\inst{1}\orcidID{0000-1111-2222-3333} \and
Polina Vinogradova\inst{1}\orcidID{0000-0003-3271-3841}}
%
\authorrunning{P. Chaidos et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Input Output, Global
\email{firstname.lastname@iohk.io}
\url{iohk.io}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
The abstract should briefly summarize the contents of the paper in
150--250 words.

\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%
\section{Introduction}

What sets us apart?

\begin{itemize}
    \item Atomicity of payment+service
    
    \item permission-less, decentralized

    \item Model for (trustless) 2-party transaction construction rather than proving things about chain/ledger state

    \item Do not require establishing a relationship with SP or any other set-up
    
    \item inherent timeliness of transaction construction incentivized by SPs desired to earn 
    their tip. This is in contrast with the possibility of stale info provided from old Mithril snapshots in other LC models
\end{itemize}

We claim that our work can be used by any UTxO or EUTxO blockchain (with some adjustments to the details of intent specification). 
We use blind signatures \cite{blindsigs}

\section{Related Work}


Our approach provides facilitates transaction submission for a light client that is not aware of the entire history of a blockchain. 
Therefore, we compare our work with existing solutions for light clients as well as mechanisms that allow the interaction with a blockchain when in resource constrained operation.
Our approach is different from a more ``traditional'' (i.e., what commonly is referred to) light client that has the primary goal of syncing to the blockchain in order to acquire the information necessary to interact with a smart contract or to submit a transaction. 
We summarize the most important concepts and works in the area of light clients below.

We first describe the common idea of a light client and then outline concepts related to our work that complement light clients. 

A summary of \textbf{light client research} can be found in~\cite{cryptoeprint:2021/1657}, listing the main functionalities a light client is expected to perform: (1) issue queries, such as for the balance of an account, or the state of a transaction, and (2) safeguard secrecy information and submit transactions to the blockchain.
In order to implement these functionalities, light clients use several generic techniques, most notably: header verification and consensus evolution verification. Compared to a \emph{full node} a light client only verifies the headers of blocks and skips the verification of transactions and account balances, a technique made popular with SPV in Bitcoin~\cite{} and nearly adopted by most practical approaches for light clients, e.g.,~\cite{Ethereumlc}.
In addition to that, consensus evolution verification is needed for proof-of-stake based blockchains as the validator set can change. 
Another common technique is to compress blockchain and/or ledger state to reduce the information a light client has to download to verify proofs and synchronize to the blockchain (see, e.g.,~\cite{cryptoeprint:2019/226}).
Some light clients use game-theoretic assumptions to implement the slashing of previously deposited collateral in case of misbehavior, for example~\cite{cryptoeprint:2020/844}.
The main cryptographic building blocks that are used to realize those techniques are succinct representation and proofs, such as data accumulators (often Merkle trees) and commitments and SNARKs.
Furthermore, suitable signatures and hash functions are needed, for example, aggregate signatures and threshold signatures. 

Most related works and ideas are \textbf{intents} and \textbf{solver networks} that attempt to establish a relationship between solvers and users via their (light) clients~\cite{ethresearch-solvers}.
A light client issues an intent via as an abstracted transaction object and solvers process the intent incentivized by transaction fee or intent execution reward. The users are then free to accept or reject a solver’s proposal.
Outsourcing transaction creation to a solver does not need for user to bridge assets cross-chain, as chains are abstracted away. In case the solvers are required to provide a deposit, slashing guarantees honest behavior of a rational actor.
While concepts around solver networks are relatively new there is currently no universal standard governing the specification for intents and abstract transaction objects. To the best of our knowledge, this is the first work describing 

We also briefly cover \textbf{payment channels}, which also constitute a concept similar to our approach: 
Payment channels describe a type of off-chain mechanism for blockchains. They allow to establish a private payment channel between two parties. The channel can be used to conduct a series of (similar) transactions without interacting with the main blockchain. The creation of a payment channel requires locking funds in a smart contract, which is used to conduct the transactions~\cite{10.1145/3133956.3134096}.



Compare our approach  with :
\begin{itemize}
    \item "Free" websites monitoring the chain -- mention they lack long-term sustainability.
    \item Bridges (trustless and trusted)
    \item Payment channels 
    \item LCs that operate on single-prover model (eg. with an established relationship via deposit)
    \item LCs that operate on multi-prover model

\subsection{Technical Background}
UTxO model
\end{itemize}

\input{model.tex}


\section{Light Client Specification}
 
 We will model light clients in terms of their functionality, restrictions and protocols for communication with full nodes. By functionality, we refer to the interaction between a light client and its user(s). To satisfy user requests a light client will need to connect to and query a number of full nodes via a set of protocols prescribed by its design.
 
 
 We describe functionality of a light client in terms of reading and posting \emph{intents} denoted as two sets of predicates $\mathcal{I}_\mathsf{read}$, $\mathcal{I}_\mathsf{post}$. When queried on a reading predicate $\mathsf{int_{read}} \in \mathcal{I}_\mathsf{read}$ at time $t_0$, the light client replies with all transactions $tx$ such that $\mathsf{int_{read}}(tx,\LState_t)=1$, where  $\LState_t$ is the state of the blockchain at time $t \geq t_0$. When queried on a posting predicate $\mathsf{int_{post}} \in \mathcal{I}_\mathsf{post}$ at time $t_0$, the light client prepares a transaction $tx_p$ such that $\mathsf{int_{post}}(tx_p,\LState_t)=1$, where $t \geq t_0$ and broadcasts it to the blockchain.
 
 [TODO: revisit time]
 [TODO: can we do the LC part of bridges with these intents?]
 
 In order to provide answers to queries by the user, a light client participates in a number of protocols between itself and a set of full nodes. These protocols may be one to one or one to many, depending on the design of the light client. We will expand on the syntax and operation of such protocols in the following subsection.
 
 Lastly, a light client is characterized in terms of restrictions placed on the resources it has available (without restrictions, we could treat a a full node of a chain as a light client). These restrictions can relate to the  communication cost to answer a series of queries, available storage, and assumptions about connectivity. On the other side, a particular light client design might limit the intents contained in $\mathcal{I}_\mathsf{read}$, $\mathcal{I}_\mathsf{post}$ to simplify its design.
 
 
 \subsection{Light Client Interactions}
 
The light client interacts with a number of full nodes. We assume that all parties know the current time up to an allowable deviation $\delta_t$. We allow for protocols featuring a single or multiple full nodes, and (orthogonally) protocols that are supported by a smart contract at the cost of additional setup. An important difference between the single and multi-node model is that existential honesty trivialises the single-node case. As such, single-node protocols are usually required to operate under more stringent security assumptions.
 
 \begin{itemize}
 
 \item User - LC interface
 
 \item LC characteristics/ limitations
   \begin{itemize}
\item What are the capabilities of a light client?

\item Does it remember all addresses it has been paid at (tx history)?

\item Do we assume that viewing keys exist? Can we assume LC can generate first x addresses from its private key in a
deterministic way? 

\item Is light client allowed to maintain state, and what state can they maintain if so? Secret key is the minimum state.
\item Sanity test: if we dismiss all requirements we should recover a full client.
\end{itemize}

 \item LC - Full Node interactions
  \begin{itemize}
  \item Protocols to support user requests
  \item Security reqs (protecting integrity/ privacy/ SPO revenue?)
\end{itemize}
 \end{itemize}
 
Can we describe the differences between light wallets, bridges and light nodes in our framework? (Probably yes). 

How can we formalize the intent of a light client without revealing secret key?

Can we have viewing keys?


\section{Threat Model}

\begin{itemize}
    \item Client finds out too much from SP answer and can submit tx without payment to SP (that’s why the inputs must be hidden)

    \item SP lies to client about the UTxOs being spent by the tx, and tricks them into doing something they didn’t want to do (that’s why 0-knowledge proof that outputs were correctly specified)

    \item Suboptimal transactions possibility : 
    Do we want to let users specify what they want optimized for in their intents (e.g. minimize fee or find best price on exchange offer)? 
    Can we assume that competition across SPs will enable client to get a better response?
    
    \item Arbitrary delay caused by SP: SP can offer to execute an intent and provide the crafted TX, but never publish it on the chain.
    For this reason, SP should provide the hashes of the UTxO references (or similar) to the light client, s.t. the LC can reuse those references in another transaction. This avoids the case where SP hangs on to the TX indefinitely or posts it at an arbitrary point in time causing two or more TXs being executed if the LC resubmits its intent/TX.
\end{itemize}


\section{Intent Specification}
Intent (DSL or predicate to describe intent of the client, ie what they want to do to the ledger state).

Give example of :

\begin{itemize}
    \item intent to mint some tokens before a deadline
    \item intent to pay x from key k1 to k2 (ie script $\fun{RequireSig}~k1$ to $\fun{RequireSig}~k2$)
\end{itemize}

\section{Light Client Protocols}

\section{Analysis}


\section{Conclusion}



\begin{credits}
\subsubsection{\ackname} A bold run-in heading in small font size at the end of the paper is
used for general acknowledgments, for example: This study was funded
by X (grant number Y).

\subsubsection{\discintname}
It is now necessary to declare any competing interests or to specifically
state that the authors have no competing interests. Please place the
statement with a bold run-in heading in small font size beneath the
(optional) acknowledgments\footnote{If EquinOCS, our proceedings submission
system, is used, then the disclaimer can be provided directly in the system.},
for example: The authors have no competing interests to declare that are
relevant to the content of this article. Or: Author A has received research
grants from Company W. Author B has received a speaker honorarium from
Company X and owns stock in Company Y. Author C is a member of committee Z.
\end{credits}
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{lcbib}

\appendix
\input{appendix.tex}
%

\end{document}
