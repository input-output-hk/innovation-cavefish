% !TEX root = ../lc_main.tex

\section{Light Client Specification}

 We model light clients in terms of their functionality, constraints, and protocols for communication with full nodes and potential service providers. By functionality, we refer to the interaction between a light client and its user(s).
 We describe the functionality of a light client in terms of constructing (posting) and verifying resolved \emph{intents}. A light client specifies the intent it wants resolved using a special domain-specific language (DSL). Then, the client sends the intent to a service provider (SP), who is incentivized to respond to this intent with an \emph{abstract transaction}. An abstract transaction is a transaction that has been modified to partially conceal data in a way that (i) allows the light client to verify that their intent has been resolved in the original transaction and (ii) does not allow the client to use the abstract transaction to form a valid transaction that avoids paying the service provider fee. 

 A light client's constraints may be on the communication cost to answer a series of queries, available state/data storage, and assumptions about connectivity. As a consequence,
  a particular light client design may be limited in the intents it can construct even if a broader class of intents is supported by available software.

%\todobox{ [TODO: revisit time] [TODO: can we do the LC part of bridges with these intents?]}

 % In order to provide answers to queries by the user, a light client participates in a number of protocols between itself and a set of full nodes. These protocols may be one to one or one to many, depending on the design of the light client.


\subsection{Intent specification}
\label{sec:dsl}

An \emph{abstract transaction}, $\TxAbs$, is the data structure that a light client receives from the service provider instead of
the full plaintext transaction (see Fig.~\ref{fig:abs-tx}). 
In $\TxAbs$, the $\fun{aux}$ and the $\inputs$ fields are removed, and instead of the $\Signature$
field, it contains only the signing keys $\fun{sigKeys}$ and not the corresponding signatures. The value of the first output is zeroed out to allow for any leftover input funds to be returned to the LC's change address. The intent a light client constructs is any expression in the DSL $\mathcal{I}_\mathsf{post}$, see Figure~\ref{fig:dsl}. 

\begin{figure}\fbox{
\begin{displaymath}
\begin{array}{rlll}
  \TxAbs &=&(\outputs: [\TxOut],\ \  \fun{validityInterval}: \Interval{\Tick},\\
  & &\ \mint: \Value,\ \  \fun{fee}: \N ,\ \  \fun{sigKeys}: \fun{Set}~\pubkey) \\
%  & &\ \texttt{//Abstract transaction type}
  \nextdef 
  \fun{mkAbs} &:& \Tx \to \TxAbs \\
  \fun{mkAbs}~\var{tx} &=& \var{tx} ~\{ ~\outputs = \var{tx} . \outputs,\\
%  & & \texttt{//Note no inputs are present}\\
  & &\ \outputs[0].\Value{} = -1, \ \ \texttt{//Leftover balance to change address} \\
% & & \texttt{//Change address receives any amount}\\
  & &\ \fun{validityInterval}  = \var{tx} . \fun{validityInterval},\\
  & &\ \mint  = \var{tx} . \mint ,\ \   \fun{fee}  = \var{tx} . \fun{fee} \\
  & &\ \fun{sigKeys}  = \fun{dom}~(\var{tx} . \sigs)~\} \\
%  & &\ \texttt{//Abstract transaction constructor}
\end{array}
\end{displaymath}}
\caption{Abstract transaction type $\TxAbs$ and constructor $\fun{mkAbs}$}
\label{fig:abs-tx}
\end{figure}

For the implementation of the example usecases of our design, we require the definition of the following functions:
\begin{itemize}
    \item[(i)] The function that constructs a transaction based on the specification (this function may fail, outputting $\fun{nothing}$ instead of a transaction, if the intent cannot be resolved), see Fig.~\ref{fig:mktospec}.
    \[ \fun{mkToSpec} : \LState \times \mathcal{I}_\mathsf{post} \to \Tx^? \]
    \item[(ii)] The function that checks that a given abstract transaction matches the intent specification, see Figure~\ref{fig:dsl}
    \[\fun{chkSpec}~(\mathcal{I}_\mathsf{post} \times \TxAbs) \to \B\]
\end{itemize}
%\textcolor{red}{pc: should chkSpec take TxAbs or TX ?}
\begin{figure}
    \textsc{$\mathcal{I}_\mathsf{post}$ Constructors}
\begin{displaymath}
\begin{array}{rlll}
    \fun{MustMint}           &: \Value \to \mathcal{I}_\mathsf{post}\\
    \fun{SpendFrom}         &: \Script \to \mathcal{I}_\mathsf{post}  \\
    \fun{MaxInterval}   &: \Slot \to \mathcal{I}_\mathsf{post}  \\
    \fun{PayTo}  &: (\Value \times \Script)  \to \mathcal{I}_\mathsf{post}  \\
    \fun{ChangeTo} &: \Script \to \mathcal{I}_\mathsf{post}  \\
    \fun{MaxFee} &: \N  \to \mathcal{I}_\mathsf{post} \\
    \fun{AndExps}  &: [\mathcal{I}_\mathsf{post}] \to \mathcal{I}_\mathsf{post} \\
\end{array}
\end{displaymath}
\nextdef
\textsc{Evaluation of $\mathcal{I}_\mathsf{post}$}
\begin{displaymath}
\begin{array}{rlll}
  \chkSpec{\_} &:& \mathcal{I}_\mathsf{post} \to \TxAbs \to \B \\
  \chkSpec{\fun{MustMint}~v} (\var{tx}) &=&  v \leq \var{tx} . \mint \\
  \chkSpec{\fun{SpendFrom}~s} (\var{tx}) &=& \applyScript{s}(\fun{dom}~(\var{tx} . \sigs), \var{tx}.\validityInterval) \\
  \chkSpec{\fun{MaxInterval}~i} (\var{tx}) &=& (\var{tx}.\validityInterval)_2 - (\var{tx}.\validityInterval)_1 \leq i \\
  \chkSpec{\fun{PayTo}~(s, v)} (\var{tx}) &=& (s, v) \in \var{tx} . \outputs  \\
  \chkSpec{\fun{ChangeTo}~s} (\var{tx}) &=& (s, \fun{consumed}~-~\fun{produced}) \in \var{tx} . \outputs  \\
  \chkSpec{\fun{MaxFee}~f} (\var{tx}) &=&  \var{tx} . \fun{fee} \leq f \\
  \chkSpec{\fun{AndExps}~[a1 ; a2 ; ... ; ak]} (\var{tx}) &=& (\chkSpec{a1}~\var{tx}) \wedge (\chkSpec{a2}~\var{tx}) \wedge ... \wedge (\chkSpec{ak}~\var{tx})
\end{array}
\end{displaymath}
\caption{$\mathcal{I}_\mathsf{post}$ constructors and evaluation}
\label{fig:dsl}
\end{figure}
Note that the function $\fun{mkToSpec}$ constructs a transaction by editing an initial transaction $\fun{initTx}_{a,mf}$ (see Figure~\ref{fig:mktospec}). This transaction includes a minimum fee $mf$ as well as a tip $\fun{tip}$ to the service provider, output to its address $a$.
These functions are defined such that for any $l,~i$, where $\fun{mkToSpec}~(l,~i) \neq \fun{nothing}$,
necessarily $\chkSpec{i}~(\fun{mkAbs}~(\fun{mkToSpec}~(l,~i))) = \true$. The design of the DSL is minimal, 
and is meant only to showcase the operation of the light client protocol.
To expand the functionality of the light client, more constraints need to be
included in the DSL, e.g., a way to limit transaction size, or support for specifying
desired token exchanges. We leave this for future work. 

We showcase two examples in the following, for a given ledger state $l$:
\begin{itemize}
    \item[($\fun{txi}_1$)] Intent to mint some token $t$ within an interval of length $j$ and maximum fee $f \leq \fun{minfee}~l$ (note that this will not be a valid transaction since it will have no inputs):
    \[ i_1 =  \fun{AndExps}~[ \fun{MustMint}~t ; \fun{MaxInterval}~j ; \fun{MaxFee}~f ; \fun{ChangeTo}~s ]\]

    \item[($\fun{txi}_2$)] Intent to pay $x$ from outputs locked by $\fun{RequireSig}~k1$ to  $\fun{RequireSig}~k2$ (note that this intent may not be possible to resolve in the key $k1$ does not have sufficient funds on the ledger $l$)
    \[ i_1 =  \fun{AndExps}~[ \fun{SpendFrom}~(\fun{RequireSig}~k1) ; \fun{PayTo}~(\fun{RequireSig}~k2,~x) ; \fun{ChangeTo}~(\fun{RequireSig}~k1)]\]
\end{itemize}
The resulting transactions are given in Figure~\ref{fig:txs}, assuming the intents can be resolved.
The minimum required capacity of our light client is to perform all the actions that are specified in the protocol we describe in the next section.

%In the next section, we describe our security requirements  for such protocols as well as some modeling assumptions  for their environment.



