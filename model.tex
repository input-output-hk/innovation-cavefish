\section{Ledger Model}
\label{sec:model}

The ledger model to which we tailor our light client design is 
a UTxO ledger with multi-asset support ($\mathsf{UTxO}_{ma}$), first introduced in \cite{utxoma}. 
The UTxO ledger model, such as the one used by BitCoin \cite{bitcoin}, Ergo \cite{ergo},
and Cardano~\cite{full-cardano}, maintains a record, called the \emph{UTxO set}, 
of transaction outputs added 
by transactions that have been applied throughout its history, but not yet spent by 
subsequent transactions. For completeness, and in order to establish notation, 
we include an overview of the $\mathsf{UTxO}_{ma}$ model. For additional notation 
explanation, see Figure \ref{fig:notation:nonstandard}.

\textbf{Multi-asset Support}. A ledger which supports transacting with not only the 
primary currency, e.g. BitCoin on the BitCoin 
platform, or Ada on Cardano, but also other types of currencies, is called 
a \emph{multi-asset ledger}. In this work, we chose to build on a multi-asset 
UTxO ledger model in order to demonstrate a broader range of usecases for our design.
We do not, however, make use of the more expressive Extended UTxO ledger model \cite{eutxoma}.
We later discuss how our design can be adjusted to both the basic UTxO model, and the 
Extended UTxO with multi-assets model. 

Each asset is uniquely identified by an $\AssetID \leteq \Policy \times \TokenName$.
Arbitrary combinations of assets are specified using a finitely-supported map 
$\Value \leteq \AssetID \mapsto \Quantity$, where, for a given $v \in \Value$,
all assets whose IDs are not 
included in the domain of $v$ are assumed to have quantity $0 \in \N$. 
This data structure 
has a partial order $\leq$, and forms a group under addition $+$, with zero being 
the empty map $\emptyset$. In our model, all assets are user-defined, meaning that a
user can introduce any asset into circulation so long as minting of this asset is allowed 
by its minting policy (which may be defined by the user themselves).

\textbf{Ledger State and the UTxO Set.} The ledger state is a
data structure which is updated by applying incoming transactions.
The state of a UTxO-based ledger 
necessarily contains a UTxO set. While realistic ledgers often contain additional 
information in their state, in our model, the ledger state is just the UTxO set.
The UTxO set is a finite map, $\UTxO \leteq \TxIn \mapsto \TxOut$. 
A transaction updates the UTxO set by either adding and removing entries. 

\textbf{Transactions}. A transaction is the following data structure :

\begin{displaymath}
    \begin{array}{rll}
        \Tx &=&(\inputs: \type{Set}~{\TxIn},\\
        & &\ \outputs: [\TxOut],\\
        & &\ \fun{validityInterval}: \Interval{\Tick},\\
        & &\ \mint: \Value,\\
        & &\ \sigs: \Signature)
    \end{array}
\end{displaymath}

An input $(\var{txid}, \var{ix}) \in \TxIn \leteq \TxId \times \N$ is a pair 
of a transaction ID and a natural number. When a transaction is applied to a UTxO 
set, its set of $\inputs$ is used to identify the entries
which the transaction is removing from the set. In each input,
$\var{txid} \in \TxId \leteq \H{}$ 
is the hash of a (previous) transaction that added that entry to the UTxO, and $\var{ix}$ 
is the index of that output in the list of outputs of that transaction.

An output $(s, v) \in \TxOut \leteq \Script \times \Value$ is a pair of a script $s$
which specifies some constraints that are checked when the output is spent, 
and the assets $v$ contained in the output. The list $\outputs$ of outputs of a transaction 
$\var{tx}$ is used to construct a set of UTxO entries that will be added to the UTxO set, such 
that the unique identifier $\var{txin}$ of each output $o \in \outputs~\var{tx}$ consists of the 
transaction hash $\fun{txid}~\var{tx}$, and the index of $o$ in the list $\outputs~\var{tx}$.
The entires added to the UTxO set by $\var{tx}$ are computed in this way by $\fun{mkOuts}$, 
see Figure \ref{fig:eutxo-types}.

A slot number $s \in \Slot$ represents blockchain time, and is specified at the block level, 
but we do not model the details of block application in this work. 
The interval $\fun{validityInterval}$ specifies the range of slot numbers for which a transaction
can be valid. The field $\sigs : \Signature \leteq \pubkey \mapsto \H $
is a set of public keys, associated with their 
signatures on the the transaction (excluding $\sigs$ itself). 

The $\mint$ field represents the assets being minted or burned by the transaction. 
Assets with positive quantities are said to be minted, while those with negative quantities 
are burned. When a transaction is applied, the constraints specified by every 
$p \in \Policy \leteq \Script$ of each type of asset specified in this field are 
checked to make sure minting/burning of this type and quantity of asset is allowed. 

\textbf{Ledger State Update. } The ledger state is updated by transaction 
application. Given a UTxO set $\var{utxo}$ and a transaction $\var{tx}$, the function 
$\fun{updateUTxO} : \UTxO \times \Tx \to \UTxO$
computes the updated UTxO set by adding and removing the appropriate entries :

\[\fun{updateUTxO}~(\var{utxo},~\var{tx})~=~\{~i\mapsto o \in \var{utxo} ~\mid~ i \notin \fun{inputs}~(tx)~\} \cup \fun{mkOuts}(tx)\]
    
While an update to the UTxO set can be computed for any transaction, only transactions that are
\emph{valid} for a given set are allowed to perform an update to the ledger state. For a given
$\var{utxo}$ set, a transaction $\var{tx}$ 
is valid whenever the function $\fun{checkTx} : \Slot \times \UTxO \times \Tx \to \B$,
applied as $\fun{checkTx}~(\var{utxo},~\var{tx})$, returns $\True$. The $\fun{checkTx}$
function is the conjunction of the constraints specified in Section \ref{sec:check-tx}.
This includes checking that the constraints of every $\Script$ run by the transaction are satisfied. 
The constructors and evaluation of $\Script$ is given in Figure \ref{fig:script}, 
and $\fun{MOf}$ is given in \ref{fig:eutxo-types}.

\begin{figure}
    \textsc{Constructors of $\Script$} 
\begin{displaymath}
\begin{array}{rlll}
    \fun{RequireMOf}         &: \N \to [\Script] &\to~ \Script \\
    \fun{RequireSig}         &: \pubkey      &\to~ \Script \\
    \fun{RequireTimeStart}   &: \Slot        &\to~ \Script \\
    \fun{RequireTimeExpire}  &: \Slot        &\to~ \Script \\
\end{array}
\end{displaymath}
\nextdef
\textsc{Evaluation of $\Script$} 
\begin{displaymath}
\begin{array}{rlll}
  \applyScript{\_} &:& \Script \to ((\type{Set} \pubkey) \times (Slot \times Slot)) \to \B \\
  \applyScript{\fun{RequireMOf}~n~ls} (\var{khs}, (t1, t2)) &=&  \fun{MOf}~0~ n ~(\applyScript{\_}~(\var{khs}, (t1, t2))) ~ls \\
  \applyScript{\fun{RequireSig}~k} (\var{khs}, (t1, t2)) &=& k~\in~\var{khs} \\
  \applyScript{\fun{RequireTimeStart}~t1'} (\var{khs}, (t1, t2)) &=& t1'~\leq~t1 \\
  \applyScript{\fun{RequireTimeExpire}~t2'} (\var{khs}, (t1, t2)) &=& t2~\leq~t2' 
\end{array}
\end{displaymath}
\caption{$\Script$ constructors and evaluation}
\label{fig:script}
\end{figure}



