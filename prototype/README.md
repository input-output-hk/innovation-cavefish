# Cavefish implementation refinements

## Context

This document describes the computation and information flows between
a light client (LC) and a service provider (SP) participating in Cavefish
protocol from the perspective of their cryptographic interactions.

In the context of Cavefish, a LC uses a DSL to describe a blockchain 
transaction it wants to send to the network. The LC is not able to 
construct the transaction by their own (due to lack of resources). A 
SP is capable of reading the LC intention (expressed in the said DSL)
and construct a valid transaction that satisfies the intent.

The high level flow in Cavefish, is:
1. The LC describes his intent using a DSL and sends it to a SP
1. the SP will send to the LC a zero knowledge proof (ZK proof, or proof 
   for short) that he has a transaction that satisfies the LC intention 
   plus pays a fee to the SP. At a high level, the proof also provides a 
   commitment to the transaction proposed by the SP.
1. The LC verifies the proof, signs the commitment and sends the 
   signature back to the SP. 
1. The SP receives the signature, attaches it to the proposed transaction
   and sends it to the network. 

As a result, the LC is able to submit its transaction and the SP is 
paid for his contribution.

## Considerations of circuits for ZK proofs

In very basic terms, in order to construct ZK proofs, a SP and a LC need
to agree on what predicates (also known as circuits) they will exchange 
proofs about. In our case, the Cavefish paper describes that the proofs 
will assert that:
- given an intent created by the LC (expressed through a DSL), and
- a transaction constructed by the SP
- a commitment to the transaction provided by the SP
Then the SP will be able to prove that its proposed transaction satisfies
the LC intent and that the transaction matches the commitment.

However, such a circuit requires a level of expressiveness that the
current implementation does not support. Beyond current state of 
development, we also identify certain consideration points in that
predicate:
1. The circuit would need to encode details about CBOR encoding. This 
   is because the Cardano transactions are encoded in CBOR. A change to
   CBOR encoding would then require to update the circuits accordingly
1. The circuit would also be tight to the intent's DSL, also leading to
   update them if the DSL is extended
1. Without an existing full implementation, we cannot predict the final
   performance of generating these proofs

Taking into account the above observations and the current state of the
circuit's development, we have considered a simplification of the circuit
and list the associated trade offs.
The predicate will be simplified as follows. Given the inputs:
- A bytestring representing a CBOR encoded Cardano transaction where some
  specific bytes (e.g. transaction inputs) have been zeroed out
- A (private) bytestring representing the real CBOR encoded transaction
  constructed by the SP
- A commitment to the full transaction provicede by the SP
The circuit verifies that the first bytestring matches the second 
bytestring in all bytes except the ones where the first string was zeroed
out. Note that this circuit may require a list of ranges that describe
exactly which positions of the first bytestring were zeroed out.

The said predicate would be used as follows:
1. The LC would express its intent in a DSL
1. The SP would construct the transaction with the said DSL and return to
   the LC the CBOR with zeroed out fields, the commitment and a ZK proof
   that the SP has a bytestring (the full CBOR) that matches the 
   commitment and the first bytestring
1. The LC would verify the proof and decode the zeroed out CBOR
1. Then LC will need to interpret the modified CBOR and check that this
   CBOR would satisfy its initial intent
1. The LC signs the commitment and gives it to the SP
1. The SP attaches the signature to the real transaction CBOR

The above flow presents the following trade offs and open questions:
Positive
1. Detaches the circuit from CBOR and DSL changes
1. It is closer to what we have today
1. It has some evidence of efficiency from the original paper results

Negative/open questions
1. It demands the LC to be able to parse the CBOR and match it with its
   intent
1. The security for the LC depends on the CBOR parser it uses. We need to
   ensure that the SP is not able to zero out something important (like
   an output of the transaction) without detection. 
1. An additional note to keep in mind is that this approach is revealing 
   the UTxOs generated by the transactions proposed by the SP. This means
   that after signing one transaction, the LC learns newly available 
   UTxOs for future transactions.

The trade offs need to be carefully evaluated. Even though this could be
a path to follow to connect the full flow, it may end up being safer to 
implement the more expressive predicate for a production implementation.
Note that the security related to not hiding undesired things in the
zeroed out CBOR may need to be re-evaluated on each update to CBOR 
encodings, or even CBOR language versions themselves.

---

## CIRCOM + snarkjs setup and flow options

In order to implement the described protocol, we rely on a cryptographic
scheme that requires:
- **a setup phase** to set system parameters in order to create/verify 
  proofs, the setup steps shown below are done by LC and SP, but could
  be simplified and performed by the LC alone, or an external trusted
  party.
- **proof generation** step done by the SP, where the SP takes the LC
  intent, finds data to construct a witness (at a high level this is 
  the concrete transaction), and generates a ZK proof that he knows a 
  solution to the LC intent
- **proof verification** step done by the LC, to check the ZK proof 
  generated by the SP

Below, we describe a possible flow of steps and data exchanges between LC
and SP. We assume they use circom and snarkjs to describe the actions 
they perform. We remind that in the next steps, the verifier is the LC,
while the prover is the SP.

## **Phase 1 â€“ Universal Setup (Circuit-agnostic)**

**Command (run by Verifier):**

```bash
snarkjs powersoftau new bn128 19 pot0.ptau
snarkjs powersoftau prepare phase2 pot0.ptau pot_final.ptau
```

* **Inputs:** none
* **Outputs:** `pot_final.ptau`
* **Exchanged:** Verifier sends `pot_final.ptau` â†’ **Prover**


## **Phase 2 â€“ Circuit Compilation**

**Command (run by Prover):**

```bash
circom circuit.circom --r1cs --wasm --sym
```

* **Outputs:**

  * `circuit.r1cs` (constraint system)
  * `circuit_js/` (WASM + witness generator)
  * `circuit.sym` (symbols file used for debugging)
* **Exchanged:** Optionally `.r1cs` (or its hash) to verifier for 
  verification

> **Note:** The verifier must have a **trusted copy of `circuit.r1cs`** 
(or its hash) to later verify `.zkey`.

## **Phase 2 â€“ Initial Circuit-Specific Setup (Prover)**

**Command (run by Prover):**

```bash
snarkjs groth16 setup circuit.r1cs pot_final.ptau circuit.zkey
```

* **Inputs:**

  * `circuit.r1cs`
  * `pot_final.ptau` (from verifier)
* **Outputs:** `circuit.zkey` (contains proverâ€™s toxic waste)
* **Exchanged:** Prover sends `circuit.zkey` â†’ **Verifier**

## **Phase 2 â€“ Verifier `.zkey` Verification and Contribution**

**Step 1 â€“ Verify `.zkey`**

**Command (Verifier):**

```bash
snarkjs zkey verify circuit.r1cs pot_final.ptau circuit.zkey
```

* **Inputs:** trusted `circuit.r1cs`, `pot_final.ptau`, received `.zkey`
* **Outputs:** OK / failure
* **Purpose:** Ensures the `.zkey` matches the expected circuit and PoT

**Step 2 â€“ Add Verifier Contribution**

**Command (Verifier):**

```bash
snarkjs zkey contribute circuit.zkey circuit_final.zkey --name="Verifier contribution"
```

* **Inputs:** verified `circuit.zkey`
* **Outputs:** `circuit_final.zkey` (toxic waste destroyed)
* **Exchanged:** Verifier sends `circuit_final.zkey` â†’ **Prover**

> **Mote:** the previous steps in phase 2 could be simplified by making
the verifier run all the commands for `.zkey` generation (skipping the
contribution from the prover). This has an advantage of allowing to 
share the same `.zkey` with all provers (SPs). 

## **Phase 2 â€“ Verification Key Export**

**Command (Verifier):**

```bash
snarkjs zkey export verificationkey circuit_final.zkey circuit_verifkey.json
```

* **Outputs:** `circuit_verifkey.json`

## **Witness Generation (Prover)**

```bash
snarkjs wtns calculate circuit_js/circuit.wasm circuit_input.json circuit.wtns
```

* **Outputs:** `circuit.wtns` (all signals)

## **Proof Generation (Prover)**

```bash
snarkjs groth16 prove circuit_final.zkey circuit.wtns circuit_proof.json circuit_public.json
```

* **Outputs:**
  * `circuit_proof.json` (proof)
  * `circuit_public.json` (public signals)
* **Exchanged:** both files to â†’  **Verifier**

## **Proof Verification (Verifier)**

```bash
snarkjs groth16 verify circuit_verifkey.json circuit_public.json circuit_proof.json
```

* **Inputs:** verification key + public signals + proof
* **Outputs:** verification result (`OK!` or failure)

### ðŸ”¹ Summary of File Roles

| File                     | Created by | Sent to            | Kept by  | Public / Private                               |
| ------------------------ | ---------- | ------------------ | -------- | ---------------------------------------------- |
| `pot_final.ptau`         | Verifier   | Prover             | Verifier | Public                                         |
| `circuit.r1cs`           | Prover     | Optional (or hash) | Both     | Circuit trusted; hash public, contents private |
| `circuit.zkey` (initial) | Prover     | Verifier           | Prover   | **Sensitive before verifier contribution**     |
| `circuit_final.zkey`     | Verifier   | Prover             | Both     | Safe to share (trapdoor destroyed)             |
| `circuit_verifkey.json`  | Verifier   | Optional           | Verifier | Public                                         |
| `circuit.wtns`           | Prover     | None               | Prover   | Private (all signals)                          |
| `circuit_proof.json`     | Prover     | Verifier           | Prover   | Public (proof only)                            |
| `circuit_public.json`    | Prover     | Verifier           | Prover   | Public (public signals)                        |

